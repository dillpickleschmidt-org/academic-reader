import { useMemo, useEffect, useRef, useCallback } from "react"
import "../styles/base-result.css"
import "../styles/html-result.css"
import "katex/dist/katex.min.css"
import "katex/dist/contrib/copy-tex"
import { ReaderLayout } from "../components/ReaderLayout"
import { useDocumentContext } from "@/context/DocumentContext"
import { useTTSChunkDetection } from "@/hooks/use-tts-chunk-detection"
import { useWordHighlighting } from "@/hooks/use-word-highlighting"
import { TTSContextMenu } from "@/components/TTSContextMenu"

interface Props {
  content: string
  imagesReady: boolean
  onDownload: () => void
  onReset: () => void
}

export function ResultPage({
  content,
  imagesReady,
  onDownload,
  onReset,
}: Props) {
  const documentContext = useDocumentContext()
  const chunks = documentContext?.chunks ?? []
  const { menuState, setMenuOpen, handleContentClick } =
    useTTSChunkDetection(chunks)

  // Enable word-level highlighting during TTS playback
  useWordHighlighting()

  const htmlContent = useMemo(() => ({ __html: content }), [content])
  const contentRef = useRef<HTMLDivElement>(null)

  // Combined click handler: internal links first, then TTS chunk detection
  const handleClick = useCallback(
    (e: React.MouseEvent) => {
      const target = e.target as HTMLElement
      const anchor = target.closest("a[href^='#']") as HTMLAnchorElement | null

      if (anchor) {
        e.preventDefault()
        const targetId = anchor.getAttribute("href")!.slice(1)
        // Try id attribute first (Datalab format), then data-block-id (our format)
        const targetEl =
          document.getElementById(targetId) ??
          document.querySelector(`[data-block-id="${targetId}"]`)
        if (targetEl) {
          targetEl.scrollIntoView({ behavior: "smooth" })
        }
        return
      }

      // Delegate to TTS chunk detection
      handleContentClick(e)
    },
    [handleContentClick],
  )

  // Detect table overflow and update shadow classes based on scroll position
  useEffect(() => {
    if (!contentRef.current) return

    const updateShadows = (el: Element) => {
      const container = el.parentElement
      if (!container) return
      const hasOverflow = el.scrollWidth > el.clientWidth
      container.classList.toggle(
        "has-overflow-left",
        hasOverflow && el.scrollLeft > 0,
      )
      container.classList.toggle(
        "has-overflow-right",
        hasOverflow && el.scrollLeft + el.clientWidth < el.scrollWidth - 1,
      )
    }

    contentRef.current.querySelectorAll(".table-scroll").forEach((el) => {
      // Compact wide tables (reduce padding + zoom)
      if (el.scrollWidth > el.clientWidth) {
        const table = el.querySelector("table")
        if (table) table.classList.add("table-compact")
      }

      updateShadows(el)
      el.addEventListener("scroll", () => updateShadows(el), { passive: true })
    })
  }, [content])

  return (
    <ReaderLayout
      onDownload={onDownload}
      onReset={onReset}
      showThemeToggle
      showSidebar
      downloadDisabled={!imagesReady}
    >
      {/* Safe: content is generated by Marker from user's own uploaded document */}
      <div
        ref={contentRef}
        onClick={handleClick}
        dangerouslySetInnerHTML={htmlContent}
      />
      <TTSContextMenu
        anchorElement={menuState.anchorElement}
        blockId={menuState.blockId}
        wordIndex={menuState.wordIndex}
        chunkContent={menuState.chunkContent}
        isOpen={menuState.isOpen}
        onOpenChange={setMenuOpen}
      />
    </ReaderLayout>
  )
}
